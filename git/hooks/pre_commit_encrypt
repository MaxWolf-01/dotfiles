#!/usr/bin/env bash
set -euo pipefail

# Pre-commit hook to encrypt files in decrypted/ to encrypted/*.age
# Only re-encrypts files that have actually changed

cd "$(git rev-parse --show-toplevel)"

KEY_FILE="$HOME/.local/secrets/age-key.txt"

if [ ! -f "$KEY_FILE" ]; then
    echo "Error: age key not found at $KEY_FILE"
    echo "Generate with: age-keygen -o $KEY_FILE"
    exit 1
fi

# Get public key from private key
public_key=$(age-keygen -y "$KEY_FILE")

# Track if any files were encrypted
encrypted_any=false

# Encrypt all files in decrypted/ (recursively)
find decrypted -type f | while read -r file; do
    # Get relative path from decrypted/
    relative_path="${file#decrypted/}"
    encrypted_file="encrypted/${relative_path}.age"

    # Check if the decrypted file has changed
    if [ -f "$encrypted_file" ]; then
        # Decrypt existing to temp and compare
        temp_decrypted=$(mktemp)
        if age -d -i "$KEY_FILE" -o "$temp_decrypted" "$encrypted_file" 2>/dev/null; then
            if cmp -s "$file" "$temp_decrypted"; then
                # Files are identical, skip re-encryption
                rm "$temp_decrypted"
                continue
            fi
        fi
        rm -f "$temp_decrypted"
    fi

    # Create directory structure in encrypted/
    mkdir -p "$(dirname "$encrypted_file")"

    echo "Encrypting $relative_path..."
    age -r "$public_key" -o "$encrypted_file" "$file"
    encrypted_any=true

    # Stage the encrypted file
    git add "$encrypted_file"

    # Unstage the plaintext file
    git rm --cached "$file" 2>/dev/null || true
done

if [ "$encrypted_any" = false ]; then
    echo "No changes detected in decrypted files, skipping re-encryption"
fi

# Exploring

- I often work in codebases with many small to medium-sized files. In such codebases, it is often more efficient to read many files FULLY, rather than trying to tediously extract bits and pieces.
- More context is generally better than less.

# Philosophy

- Everything should be made as simple as possible, but no simpler.
  - Build the simplest thing that solves the problem.
  - Complexity is the enemy of understanding.

- Avoid external dependencies whenever possible. Every dependency adds:
  - Complexity
  - Security vulnerabilities  
  - Maintenance burden
  - Things you don't understand

Every LOC in a dependency is like a LOC in your codebase - just with less control.

The Development Process:
1. **Make it work** (simplest possible solution)
2. **Make it beautiful** (refactor, improve design)
3. **Make it fast** (optimize, only when needed)

This order is crucial. Most people get it backwards.

- Don't think about shortcuts and abstractions early
  - Premature abstraction is worse than premature optimization
  - Don't solve problems you don't have
  - *Abstractions should emerge from concrete implementations, not precede them*

- RISC Philosophy Applied to Software
  - Few, composable primitives > many specialized functions
  - Transparent implementations > black box magic
  - Understanding every layer > trusting abstractions

- Anti-Pattern: "Spray and Pray" Coding
  - The goal isn't to write code quickly - it's to write correct code you understand.
  - Many developers (and especially AIs):
    - Write lots of code quickly
    - Hope it works
    - Add more code when it doesn't
    - End up with complex, buggy systems they don't understand
  - You should do the opposite:
    - Write minimal code
    - Debug thoroughly
    - Understand every failure
    - End up with simple, correct systems

- Code Aesthetics Matter
  - Self-documenting code > comments > documentation
  - Scripts > guides/guis
  - If you need extensive comments, your code is too complex

- Anti-Pattern: Modern Software
  - What to avoid:
    - Over-engineering
    - Solving hypothetical problems
    - Adding layers of indirection

- **Question every abstraction** - does it isolate an independent subsystem, or just add complexity?
- **If you can't explain it simply (to yourself / to the user), you don't understand it** - iterate until you can
- **The best code is code that doesn't exist** - every line of code is a liability
- **Complexity comes from solving problems you don't actually have**
- -> While others add layers, you remove them. While others abstract, you understand. While others depend, you build.

- Good abstractions are key 
    - They should simplify without hiding complexity
    - They should be intuitive and easy to reason about
    - They should emerge from concrete implementations, not precede them

